<!--
Author: Yazen Ghannam
Spring 2013
CAP 6721
Assignment 1
-->
<!DOCTYPE html>
<html>
	<head>
		<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
		<meta content="utf-8" http-equiv="encoding">
		<script type="text/javascript" src="gl-matrix.js"></script>
		<script id="openclProgram" type="text/x-opencl">
			
			#define Pi 3.14159265358979323846f
			#define EPSILON 0.01
			
			typedef struct {
				float3 d, o;
			}Ray;
			
			typedef struct{
				float3 c;
				float r;
			}Sphere;
			
			typedef struct{
				float t;
				int shapeIndex;
				float3 P;
				float3 N;
			}Intersection;
			
			
			float rayPlane(
				Ray ray, 
				float3 normal,
				float3 point){
					float t = INFINITY;					
					float rayNormal = dot(ray.d, normal);
					if( rayNormal != 0){
						t = dot(point-ray.o, normal)/rayNormal;
					}					
					return (t>0) ? t : INFINITY;
				}
				
			float3 rayTriangle(
				Ray ray, 
				float3 p0,
				float3 p1,
				float3 p2){
				float t = INFINITY;
				
				/*
				float3 normal = cross(p1-p0, p2-p0);
				t = rayPlane(rayOrigin, rayDirection, normal, p0);
				if(t > 0){
					float3 p = rayOrigin + t*rayDirection;
					float normalSquared = dot(normal, normal);
					float alpha = dot(normal, cross(p-p0, p2-p0))/normalSquared;
					float beta = dot(normal, cross(p1-p0, p-p0))/normalSquared;
					
					if(alpha < 0 || beta < 0 || alpha+beta > 1){
						t = 0;
					}
				}
				*/
				float3 e1 = p1-p0;
				float3 e2 = p2-p0;
				float3 s = ray.o-p0;
				float invDet = 1.0f / dot(cross(ray.d, e2), e1);
				t = invDet * dot(cross(s, e1), e2);
				float alpha = invDet * dot(cross(ray.d, e2), s);
				float beta = invDet * dot(cross(s, e1), ray.d);
				
				if(t < 0 || alpha < 0 || beta < 0 || alpha+beta > 1){
					t = INFINITY;
				}
				
				return (float3)(t, alpha, beta);
			}
			float raySphere(
				Ray ray, 
				Sphere sphere,
				bool second){
				float t = INFINITY;
				float a = dot(ray.d, ray.d);
				float b = 2.0f * dot(ray.o - sphere.c ,ray.d);
				float c = dot(ray.o-sphere.c,ray.o-sphere.c) - sphere.r*sphere.r;
				float discriminant = b*b - 4.0f*a*c;
				if (discriminant == 0){
					t = -b/(2.0f*a);
				}
				else{
					float root = sqrt(discriminant);
					float q = (b < 0) ? (-0.5f*(b-root)) : (-0.5f*(b+root));
					float x1 = q/a;
					float x2 = c/q;
					if(x1 > 0 && x2 > 0){
						if(second)
							return (x1 > x2) ? x1:x2;
						return (x1 < x2) ? x1:x2;
					}
					else if (x1 > 0 && x2 <= 0){
						return x1;
					}
					else if (x1 <= 0 && x2 > 0){
						return x2;
					}
					else{
						return INFINITY;
					}
				}
				//return t;
			}
			
			float3 reflect(float3 normal, float3 incident){
			
				return  2 * normal * clamp(dot(normalize(incident), normal), 0.0f, 1.f) - normalize(incident);
			
			}
			
			float boundingBoxIntersect(Ray ray, float3 boundMin, float3 boundMax){
				float temp = 1.f / ray.d.x;
				float txmin = (boundMin.x - ray.o.x) * temp;
				float txmax = (boundMax.x - ray.o.x) * temp;
				if( txmin > txmax){
					temp = txmin;
					txmin = txmax;
					txmax = temp;
				}
					
				temp = 1.f / ray.d.y;
				float tymin = (boundMin.y - ray.o.y) * temp;
				float tymax = (boundMax.y - ray.o.y) * temp;
				if( tymin > tymax){
					temp = tymin;
					tymin = tymax;
					tymax = temp;
				}
					
				temp = 1.f / ray.d.z;
				float tzmin = (boundMin.z - ray.o.z) * temp;
				float tzmax = (boundMax.z - ray.o.z) * temp;
				if( tzmin > tzmax){
					temp = tzmin;
					tzmin = tzmax;
					tzmax = temp;
				}
					
				float tmin = max(txmin, max(tymin, tzmin));
				float tmax = min(txmax, max(tymax, tzmax));
					
				return (tmin < tmax) ? tmin : INFINITY;
			}
			
			float3 transformRayDirection(float3 localDirection, float3 U, float3 V, float3 W){
				float3 world;

				world.x = U.x*localDirection.x + V.x*localDirection.y + W.x*localDirection.z;
				world.y = U.y*localDirection.x + V.y*localDirection.y + W.y*localDirection.z;
				world.z = U.z*localDirection.x + V.z*localDirection.y + W.z*localDirection.z;
				return world;
			}
			
			Intersection intersect(
				Ray ray, 
				bool isShadowRay, 
				int shapeType, 
				int numShapes, 
				__global float16 *shapeData, 
				__global float4 *shapeNormals,
				__global uint4 *shapeIndices){
				
				Intersection intersection;
				intersection.t = INFINITY;				
				intersection.shapeIndex = -1;
				
				unsigned int i = 0;
				if(shapeType == 1){
					for( i = 0; i < numShapes; i++){
						Sphere sphere;
						sphere.c = shapeData[i].s012;
						sphere.r = shapeData[i].s3;
						float rv = raySphere(ray, sphere, false);
						if ( rv < intersection.t && rv > EPSILON){
							intersection.t = rv;
							intersection.shapeIndex = i;
							
							if(isShadowRay){
								break;
							}
						}
					}
					intersection.P = ray.o + intersection.t*ray.d;
					intersection.N = normalize(intersection.P - shapeData[intersection.shapeIndex].s012);
				}
				else if(shapeType == 2){
					float alpha, beta;
					for( i = 0; i < numShapes; i++){
						float3 p0 = shapeData[shapeIndices[i].x].s012;
						float3 p1 = shapeData[shapeIndices[i].y].s012;
						float3 p2 = shapeData[shapeIndices[i].z].s012;
						float3 rv = rayTriangle(ray, p0, p1, p2);
						if ( rv.x < intersection.t  && rv.x > EPSILON){
							intersection.t = rv.x;
							alpha = rv.y;
							beta = rv.z;
							intersection.shapeIndex = i;
							
							if(isShadowRay){
								break;
							}
						}
					}
					intersection.P = ray.o + intersection.t*ray.d;
					float3 n0 = shapeNormals[shapeIndices[intersection.shapeIndex].x].xyz;
					float3 n1 = shapeNormals[shapeIndices[intersection.shapeIndex].y].xyz;
					float3 n2 = shapeNormals[shapeIndices[intersection.shapeIndex].z].xyz;
					intersection.N = normalize( (1-alpha-beta)*n0 + alpha*n1 + beta*n2);
				}				
				return intersection;
			}
			
			Intersection intersectGrid(
				Ray ray, 
				bool isShadowRay, 
				int shapeType, 
				int voxelIndex,
				__global int *gridMetadata,
				__global int *gridVoxels,
				__global float16 *shapeData, 
				__global float4 *shapeNormals,
				__global uint4 *shapeIndices){
				
				Intersection intersection;
				intersection.t = INFINITY;				
				intersection.shapeIndex = -1;
				
				int numShapes = gridMetadata[voxelIndex*2];
				int offset = gridMetadata[voxelIndex*2 + 1];
				
				if(numShapes > 0){
				
					int i = 0;
					if(shapeType == 1){
						for( i = 0; i < numShapes; i++){
							Sphere sphere;
							sphere.c = shapeData[gridVoxels[offset+i]].s012;
							sphere.r = shapeData[gridVoxels[offset+i]].s3;
							float rv = raySphere(ray, sphere, false);
							if ( rv < intersection.t ){
								intersection.t = rv;
								intersection.shapeIndex = gridVoxels[offset+i];
								
								if(isShadowRay){
									break;
								}
							}
						}
						intersection.P = ray.o + intersection.t*ray.d;
						intersection.N = normalize(intersection.P - shapeData[intersection.shapeIndex].s012);
					}
					else if(shapeType == 2){
						float alpha, beta;
						for( i = 0; i < numShapes; i++){
							float3 p0 = shapeData[shapeIndices[gridVoxels[offset+i]].x].s012;
							float3 p1 = shapeData[shapeIndices[gridVoxels[offset+i]].y].s012;
							float3 p2 = shapeData[shapeIndices[gridVoxels[offset+i]].z].s012;
							float3 rv = rayTriangle(ray, p0, p1, p2);
							if ( rv.x < intersection.t ){
								intersection.t = rv.x;
								alpha = rv.y;
								beta = rv.z;
								intersection.shapeIndex = gridVoxels[offset+i];
								
								if(isShadowRay){
									break;
								}
							}
						}
						intersection.P = ray.o + intersection.t*ray.d;
						float3 n0 = shapeNormals[shapeIndices[intersection.shapeIndex].x].xyz;
						float3 n1 = shapeNormals[shapeIndices[intersection.shapeIndex].y].xyz;
						float3 n2 = shapeNormals[shapeIndices[intersection.shapeIndex].z].xyz;
						intersection.N = normalize( (1-alpha-beta)*n0 + alpha*n1 + beta*n2);
					}	
				}
				return intersection;
			}
			
			int3 gridIndex(float3 point, float3 boundMin, float3 boundSize, float3 gridRes){
				return (int3)(	(int)clamp( round((point.x-boundMin.x)/boundSize.x), 0.f, gridRes.x-1.f),
								(int)clamp( round((point.y-boundMin.y)/boundSize.y), 0.f, gridRes.y-1.f),
								(int)clamp( round((point.z-boundMin.z)/boundSize.z), 0.f, gridRes.z-1.f));			
			}
			
			bool isLightInShape(Intersection intersection, __global float16* shapeData, Sphere L){
				return all(isless(L.c, shapeData[intersection.shapeIndex].s012+shapeData[intersection.shapeIndex].s3)) 
					&& all(isgreater(L.c, shapeData[intersection.shapeIndex].s012-shapeData[intersection.shapeIndex].s3)) ;
			}
			
			float random(unsigned int *seed0, unsigned int *seed1) 
			{
				*seed0 = 36969 * ((*seed0) & 65535) + ((*seed0) >> 16);
				*seed1 = 18000 * ((*seed1) & 65535) + ((*seed1) >> 16);

				unsigned int ires = ((*seed0) << 16) + (*seed1);

				//Convert to float
				union {
					float f;
					unsigned int ui;
				} res;
				res.ui = (ires & 0x007fffff) | 0x40000000;

				return (res.f - 2.f) / 2.f;
			}
			
			float calcRho(float cosI, float cosT, float n1, float n2){
				float rPara = (n2 * cosI - n1 * cosT) / (n2 * cosI + n1 * cosT);
				float rPerp = (n1 * cosI - n2 * cosT) / (n1 * cosI + n2 * cosT);
				
				return (rPara * rPara + rPerp * rPerp)/2.f;			
			}
			__kernel void clearRaster(
				const int columns,
				__global uchar4 *raster){
					const int col = get_global_id(0);
					const int row = get_global_id(1);
					raster[row * columns + col] = (uchar4)(0,0,0,255);
				}
			
			__kernel void getPixelColor(
				const int shapeType,
				const int numShapes,
				__global float4 *viewData,
				__global float16 *shapeData,
				__global float4 *shapeNormals,
				__global uint4 *shapeIndices,
				__global int *gridMetadata,
				__global int *gridVoxels,
				__global uchar4 *raster,
				__global unsigned int *seeds,
				__global unsigned int *counters,
				__global float16 *debug){
				
					const int col = get_global_id(0);
					const int row = get_global_id(1);
					
					const int columns = (int) viewData[0].x;
					const int rows = (int) viewData[0].y;
					const float width = viewData[0].z;
					const float height = viewData[0].w;
					
					float3 boundMin = viewData[1].xyz;
					float3 boundMax = viewData[2].xyz;
					
					float3 gridRes = viewData[3].xyz;
					
					float4 flags = viewData[4];
					
					float3 eye = viewData[5].xyz;
					float3 U = viewData[6].xyz;
					float3 V = viewData[7].xyz;					
					float3 W = viewData[8].xyz;
					
					// int numIter = 0;
					// int3 gridI = (int3)(0,0,0);
					
					
					
					//float enableDiffuse = viewData[7].x;
					//float enableSpecular = viewData[7].x;
					//float enableShadows = viewData[7].x;
					//float enableInterreflection = viewData[7].x;
					bool accelerated = (flags.x == 1.0f);
					
					// Send MxN number of rays through pixel
					int m, n;
					int M = 4, N = 4;
					for(m = 0; m < M; m++)
						for(n = 0; n < N; n++){
					
						unsigned int s1 = seeds[2*(row*columns+col)];
						unsigned int s2 = seeds[2*(row*columns+col)+1];
						float r1 = (m+random(&s1, &s2))/M;
						float r2 = (n+random(&s1, &s2))/N;

						float3 localDirection;
						localDirection.x = width * ( (r1+col)/columns - 0.5f);
						localDirection.y = height * (0.5f - (r2+row)/rows);
						localDirection.z = -1.f;					
						
						Ray worldRay;
						worldRay.o = eye;
						worldRay.d = transformRayDirection(localDirection, U, V, W);
						
						// for(int i = 0; i < numShapes; i++)
							// debug[i] = shapeData[i];//(float4)(0,0,0,0);
						//debug[0] = shapeData[i];
						
						uchar4 color = (uchar4)(0, 128, 0, 255);
						
						float tmin = boundingBoxIntersect(worldRay, boundMin, boundMax);
						if( tmin < INFINITY ){
						
							Intersection intersection;
							
							
							Sphere lightSource;// = (float3)(50.f, 50.6f, 81.6f);
							float3 lightIntensity = (float3)(1.f, 1.f, 1.f);
							float lightArea = 0;
							
							for(int i = 0; i < numShapes; i++){
								if(shapeData[i].s5 == 1){
									lightSource.c = shapeData[i].s012;
									lightSource.r = shapeData[i].s3;
									lightIntensity = shapeData[i].scde;
									lightArea = 4.f * Pi * lightSource.r * lightSource.r;
									break;
								}
							}
							// float4 kd = (float4)(0.6f, 0.6f, 0.6f, 1.f);
							// float4 ks = (float4)(0.4f,0.4f,0.4f,1.f);
							// float4 ka = (float4)(0.1f, 0.1f, 0.1f, 1.f);
							float shininess = 10;
							float3 radiance = (float3)(0, 0, 0);
													
							
							if(accelerated){					
								
								float3 boundSize = boundMax-boundMin;
								
								int di = (worldRay.d.x >= 0) ? 1 : -1;
								int xOutOfRange = (worldRay.d.x >= 0) ? (int)gridRes.x : -1;
								float dTx = boundSize.x / fabs(worldRay.d.x);
								
								int dj = (worldRay.d.y >= 0) ? 1 : -1;
								int yOutOfRange = (worldRay.d.y >= 0) ? (int)gridRes.y : -1;
								float dTy = boundSize.y / fabs(worldRay.d.y);
								
								int dk = (worldRay.d.z >= 0) ? 1 : -1;
								int zOutOfRange = (worldRay.d.z >= 0) ? (int)gridRes.z : -1;
								float dTz = boundSize.z / fabs(worldRay.d.z);
								
								
								bool intersected = false;
								float tCurrent = max(0.f, tmin);
								float3 gridPoint = worldRay.o + tCurrent * worldRay.d;
								int3 gridCoord = gridIndex(gridPoint, boundMin, boundSize, gridRes);							
								float dX = boundSize.x / gridRes.x;
								float txNext = (di == 1) ? 
									tCurrent+((boundMin.x + (gridCoord.x+di) * dX - gridPoint.x) / worldRay.d.x) :
									tCurrent+((boundMin.x + (gridCoord.x) * dX - gridPoint.x) / worldRay.d.x);
								float dY = boundSize.y / gridRes.y;
								float tyNext = (dj == 1) ?
									tCurrent+((boundMin.y + (gridCoord.y+dj) * dY - gridPoint.y) / worldRay.d.y) :
									tCurrent+((boundMin.y + (gridCoord.y) * dY - gridPoint.y) / worldRay.d.y);
								float dZ = boundSize.z / gridRes.z;
								float tzNext = (dk == 1) ?
									tCurrent+((boundMin.z + (gridCoord.z+dk) * dZ - gridPoint.z) / worldRay.d.z) :
									tCurrent+((boundMin.z + (gridCoord.z) * dZ - gridPoint.z) / worldRay.d.z);
																
								while(!intersected){
									
									if( gridCoord.x == xOutOfRange || gridCoord.y == yOutOfRange || gridCoord.z == zOutOfRange)
										break;
									
									//numIter++;
									int voxelIndex = gridCoord.z + ( gridCoord.y + gridCoord.x*(int)gridRes.y) * (int)gridRes.z;
									
									intersection 
										= intersectGrid(worldRay, false, shapeType, voxelIndex, gridMetadata, gridVoxels, shapeData, shapeNormals, shapeIndices);
									
									intersected = (intersection.t < INFINITY);
									
									if(!intersected){
										if(txNext < tyNext && txNext < tzNext){
											gridCoord.x += di;
											txNext += dTx;
										}										
										else if(tyNext < txNext && tyNext < tzNext){
											gridCoord.y += dj;
											tyNext += dTy;
										}
										else{//if(tzNext < txNext && tzNext < tyNext){
											gridCoord.z += dk;
											tzNext += dTz;
										}		
									}
								}
								
								// gridI = gridCoord;
								
							}
							else{
								Ray ray;
								ray.o = worldRay.o;
								ray.d = worldRay.d;
								
								float3 reflectance = (float3)(1.f, 1.f, 1.f);
								for(int i = 0; i < 7; i++){
									intersection 
										= intersect(ray, false, shapeType, numShapes, shapeData, shapeNormals, shapeIndices);	
									if (intersection.t < INFINITY){
								
										// Reverse Normal if Light Source is within Shape
										if(isLightInShape(intersection, shapeData, lightSource))
											intersection.N = -intersection.N;
										
										// Sample Light Source
										float3 lightSamplePoint;
										float3 temp;
										temp.z = random(&s1, &s2) * 2.f - 1.f;
										float phi = 2.f * Pi * random(&s1, &s2);
										float rTemp = sqrt(1.f - temp.z * temp.z);
										temp.x = rTemp * cos(phi);
										temp.y = rTemp * sin(phi);
										lightSamplePoint.x = lightSource.c.x + lightSource.r * temp.x;
										lightSamplePoint.y = lightSource.c.y + lightSource.r * temp.y;
										lightSamplePoint.z = lightSource.c.z + lightSource.r * temp.z;
										float3 lightDir = lightSamplePoint-intersection.P;
										float lightDirLength = length(lightDir);
										float invPiR2 = 1.f/(Pi * lightDirLength * lightDirLength);
										
										Ray shadowRay;
										shadowRay.o = intersection.P;
										shadowRay.d = lightDir;//lightSamplePoint-intersection.P;
										Intersection shadowIntersection 
											= intersect(shadowRay, true, shapeType, numShapes, shapeData, shapeNormals, shapeIndices);
										float tLight = raySphere(shadowRay, lightSource, false);
										
										float4 materialFlags = shapeData[intersection.shapeIndex].s4567;
										
										// Diffuse Reflectance
										if(materialFlags.x == 1){
										
											reflectance *= shapeData[intersection.shapeIndex].s89a ;
											
											// Direct Illumination
											if(shadowIntersection.t >= tLight){
												radiance += reflectance
															* lightIntensity 
															* lightArea 
															* invPiR2 
															* clamp(dot(intersection.N, normalize(lightDir)), 0.0f, 1.f)
															* clamp(dot(lightSamplePoint-lightSource.c, -normalize(lightDir)), 0.0f, 1.f);
											}
											
											// Get Random Sample on Unit Hemisphere
											// Create local coordinate frame for intersection
											// Transform sample to global coordinate frame
											
											// Start with Normal, find smallest absolute component make it 1
											// Cross product with Normal and New vector e.g. N x (N.x, N.y, 1)
											// W = N, U = (N.x, N.y, 1), V = W x U
											float3 temp = (fabs(intersection.N.x) > 0.1f) ? (float3)(0.f, 1.f, 0.f):(float3)(1.f, 0.f, 0.f);//intersection.N;
											// if(fabs(temp.x) < fabs(temp.y) && fabs(temp.x) < fabs(temp.z))
												// temp.x = 1.f;
											// else if(fabs(temp.y) < fabs(temp.x) && fabs(temp.y) < fabs(temp.z))
												// temp.y = 1.f;
											// else
												// temp.z = 1.f;
											float3 Wn = intersection.N;
											float3 Un = normalize(cross(temp, Wn));;
											float3 Vn = cross(Wn, Un);
											
											float3 sampleDir;
											sampleDir.z = random(&s1, &s2);
											float phi = 2.f * Pi * random(&s1, &s2);
											float r = sqrt(1.f - sampleDir.z*sampleDir.z);
											sampleDir.x = r * cos(phi);
											sampleDir.y = r * sin(phi);
											ray.d.x = sampleDir.x * Un.x + sampleDir.y * Vn.x + sampleDir.z * Wn.x;
											ray.d.y = sampleDir.x * Un.y + sampleDir.y * Vn.y + sampleDir.z * Wn.y;
											ray.d.z = sampleDir.x * Un.z + sampleDir.y * Vn.z + sampleDir.z * Wn.z;
											ray.o = intersection.P;
										}
										
										// Emittance
										if(materialFlags.y == 1){
											radiance += shapeData[intersection.shapeIndex].scde;
											break; // Break ray path
										}
										
										
										// Use Fresnel to calculate probability and select reflectance or transmission
										
										// Refractive Index / Specular Transmittance
										if(materialFlags.w != 0){
											//radiance += (float3)(0.f, 0.f, 1.f);
											reflectance *= shapeData[intersection.shapeIndex].scde;
											float refractiveIndex = 1.9f;//shapeData[intersection.shapeIndex].s7;
											
											float interiorRefractiveRatio = 1.f/refractiveIndex;
											float cosI = clamp(dot(normalize(-ray.d), intersection.N), 0.f, 1.f);
											float sinT2 = interiorRefractiveRatio * interiorRefractiveRatio * (1.f - cosI * cosI);
											if (sinT2 >= 1.f){
												// break;
												if(shadowIntersection.t >= tLight){
													float3 View = normalize( -ray.d);
													float3 R = reflect(intersection.N, lightDir);	
													radiance += reflectance * invPiR2 * pow(clamp(dot(View, R), 0.0f, 1.f), shininess);
												}
												
												ray.d = reflect(intersection.N, ray.o-intersection.P);
												ray.o = intersection.P;
												continue;
											}
											
											Ray interiorRefractedRay;
											interiorRefractedRay.o = intersection.P;
											interiorRefractedRay.d = interiorRefractiveRatio * normalize(ray.d) - ( interiorRefractiveRatio * cosI + sqrt(1.f - sinT2)) * intersection.N;
											
											float cosT = clamp(dot(-intersection.N, interiorRefractedRay.d), 0.f, 1.f);
											float rho = calcRho(cosI, cosT, 1.f, refractiveIndex);
											
											// Reflect
											if(random(&s1, &s2) < rho){
												// Direct Illumination
												if(shadowIntersection.t >= tLight){
													float3 View = normalize( -ray.d);
													float3 R = reflect(intersection.N, lightDir);	
													radiance += reflectance * pow(clamp(dot(View, R), 0.0f, 1.f), shininess);
												}
												
												ray.d = reflect(intersection.N, ray.o-intersection.P);
												ray.o = intersection.P;
											}
											
											// Refract
											else{
											
												Intersection refractedIntersection;
												Sphere current;
												current.c = shapeData[intersection.shapeIndex].s012;
												current.r = shapeData[intersection.shapeIndex].s3;
												float tempT = raySphere(interiorRefractedRay, current, false);
												if(tempT < EPSILON || tempT == INFINITY)
													break;
												refractedIntersection.t = tempT;
												refractedIntersection.P = interiorRefractedRay.o + refractedIntersection.t * interiorRefractedRay.d;
												refractedIntersection.N = -normalize(refractedIntersection.P - current.c);												
												
												cosI = clamp(-dot(normalize(interiorRefractedRay.d), refractedIntersection.N), 0.f, 1.f);
												sinT2 = refractiveIndex * refractiveIndex * (1.f - cosI * cosI);
												if ( sinT2 >= 1.f){
													// Direct Illumination
													if(shadowIntersection.t >= tLight){
														float3 View = normalize( -ray.d);
														float3 R = reflect(intersection.N, lightDir);	
														radiance += reflectance * pow(clamp(dot(View, R), 0.0f, 1.f), shininess);
													}
													
													ray.d = reflect(intersection.N, ray.o-intersection.P);
													ray.o = intersection.P;		
													continue;
												}												
												
												ray.o = refractedIntersection.P;
												ray.d = refractiveIndex * normalize(interiorRefractedRay.d) - ( refractiveIndex * cosI + sqrt(1.f - sinT2)) * refractedIntersection.N;
											}
										}
									}
									else{
										break;
									}
								}
								
									unsigned int counter = counters[row * columns + col];
									
									float3 Intensity = clamp(radiance, 0.0f, 1.f);
									float3 oldIntensity = (float3)((float)raster[row * columns + col].x, (float)raster[row * columns + col].y, (float)raster[row * columns + col].z)  / 255.f;
									float3 newIntensity = ((float)(counter) * oldIntensity + Intensity) / (float)(++counter);
									
									counters[row * columns + col] = counter;
									
									uchar red = (uchar) round(255*newIntensity.x);
									uchar green = (uchar) round(255*newIntensity.y);
									uchar blue = (uchar) round(255*newIntensity.z);
									color = (uchar4)(red, green, blue, 255);
									
									
								}
							}
						// for(int i = 0; i < numShapes; i++)
							// debug[i] = shapeData[i];
						
						// Write local seeds back to buffer
						seeds[2*(row*columns+col)] = s1;
						seeds[2*(row*columns+col)+1] = s2;
						
						raster[row * columns + col] = color;
					}
				}
		</script>
		<script type="text/javascript">
			var model = null;
			var platforms = null;
			var devices = [];
			var canvas = null;
			var canvasCtx = null;
			var raster = null;
			var rv = null;
			var device = null;
			var clCtx = null;
			var clCQ = null;
			var clProgram = null;
			var clKernels = new Object();
			var clBuffers = new Object();
			var shapeType = 0;
			var numShapes = 0;
			var shapeData = new Array();
			var shapeNormals = new Array();
			var shapeIndices = new Array();
			var boundingVolume;
			var viewDimensions = null;
			var flags = [0, 0, 0, 0];
			var camera = new Object();
			var rotate = false;
			var sceneLoaded = false;
			var acceleration = 0;
			var localWS = null;
			var globalWS = null;
			var seeds;
			var runCount = 0;
			var render = true;
			
			function parseJSON(jsonFile){
				var xhttp = new XMLHttpRequest();
				xhttp.open("GET", jsonFile, false);				
				xhttp.overrideMimeType("application/json");
				xhttp.send(null);
				//console.log(jsonFile);
				//console.log(xhttp);
				return JSON.parse(xhttp.responseText);
			}
			
			function loadFile(){
				model = parseJSON(document.getElementById("inputFile").value);
				//console.log(model);
				loadScene();
			}
			
			function padArray(array, currentSize){
				var paddedArray = new Array();
				var j = 0;
				for(var i = 0; i < array.length; i++, j++){
					if(i > 0 && i % currentSize == 0){
						paddedArray[j++] = 0;
						//paddedArray[++j] = array[i];
					}
					paddedArray[j] = array[i];
				}
				paddedArray[j] = 0;
				return paddedArray;
			}
			
			function vecLength(array){
				var total = 0;
				for(x in array){
					total += array[x]*array[x];
				}
				return Math.sqrt(total);
			}
			
			function normalize(array){
				var length = vecLength(array);
				for(x in array){
					array[x] /= length;
				}
				return array;
			}
			
			function cross(a, b){
				if(a.length != b.length || a.length != 3)
					throw "cross: vectors must be length 3.";
				var c = new Array();
				c[0] = a[1]*b[2] - a[2]*b[1];
				c[1] = -(a[0]*b[2] - a[2]*b[0]);
				c[2] = a[0]*b[1] - a[1]*b[0];
				
				return c;
			}
			
			function addVec(a, b){
				if(a.length != b.length)
					throw "subtractVec: vectors must be same length.";
				
				var c = new Array();
				for (x in a){
					c[x] = a[x]+b[x];
				}
				
				return c;
			}
			
			function subtractVec(a, b){
				if(a.length != b.length)
					throw "subtractVec: vectors must be same length.";
				
				var c = new Array();
				for (x in a){
					c[x] = a[x]-b[x];
				}				
				return c;
			}
			
			function divideVec(a, num){				
				for (x in a){
					a[x] /= num;
				}				
				return a;
			}
			
			function updateRotate(){
				rotate = !rotate;
			}
			
			function updateAcceleration(){
				acceleration = document.getElementById("acceleration").checked ? 1.0 : 0.0;
				flags = [acceleration, 0, 0, 0];
			}
			
			function updateCamera(){
				camera.phi += Math.PI/90;
				//camera.theta += Math.PI/360;
				camera.eye[0] = camera.radius * Math.sin(camera.theta) * Math.cos(camera.phi);
				camera.eye[1] = camera.radius * Math.cos(camera.theta);
				camera.eye[2] = camera.radius * Math.sin(camera.theta) * Math.sin(camera.phi);//[boundingVolume.center[0], boundingVolume.center[1], boundingVolume.center[2]+boundingVolume.diagonal];
				
				var W = normalize( subtractVec(camera.eye, camera.at));
				var U = normalize( cross(camera.up, W));
				var V = cross( W, U);				
				var cameraData = padArray(camera.eye.concat(U, V, W), 3);
				var viewData = viewDimensions.concat(flags, cameraData);
			
				//console.log(cameraData);
			
			}
			
			function updateScene(){
				//for(var i = 0; i < canvas.width*canvas.height; i++){
				//	seeds[i] = Math.floor(Math.random()*37000);
				//}
				
				//clCQ.enqueueWriteBuffer(clBuffers.seedsBuffer, true, 0, 4*seeds.length, seeds, []);
				var startTime = new Date().getTime();
				clCQ.enqueueNDRangeKernel(clKernels.colorKernel, globalWS.length, [], globalWS, localWS, []);
				clCQ.finish();
				var endTime = new Date().getTime();
				runCount++;
				if(runCount % 5 == 0)
					console.log("Run count: "+runCount);
				//console.log("Compute time: "+(endTime-startTime));	
				clCQ.enqueueReadBuffer(clBuffers.rasterBuffer, true, 0, canvas.width*canvas.height*4, raster.data, []);
				canvasCtx.putImageData(raster, 0, 0);
			}
			
			function createBoundingVolume(){
				boundingVolume = new Object();
				
				var xmin = Number.MAX_VALUE;
				var ymin = Number.MAX_VALUE;
				var zmin = Number.MAX_VALUE;
					
				var xmax = Number.MIN_VALUE;
				var ymax = Number.MIN_VALUE;
				var zmax = Number.MIN_VALUE;
				
				if(shapeType == 1){
				
					var spheres = shapeData;
					for ( var i = 0; i < spheres.length; i+=16){
						var centers = [spheres[i], spheres[i+1], spheres[i+2]];
						var radius = spheres[i+3];
						xmin = Math.min(xmin, centers[0]-radius);
						ymin = Math.min(ymin, centers[1]-radius);
						zmin = Math.min(zmin, centers[2]-radius);
						
						xmax = Math.max(xmax, centers[0]+radius);
						ymax = Math.max(ymax, centers[1]+radius);
						zmax = Math.max(zmax, centers[2]+radius);
					}
					boundingVolume.min = [xmin, ymin, zmin];
					boundingVolume.max = [xmax, ymax, zmax];
					boundingVolume.center = divideVec(addVec(boundingVolume.max, boundingVolume.min), 2);
					boundingVolume.diagonal = vecLength(subtractVec(boundingVolume.max, boundingVolume.min));
					//console.log("BB: ", boundingVolume);
				}
				else if(shapeType == 2){					
					
					var vertices = shapeData;
					for( var i = 0; i < vertices.length; i+=4){
						xmin = Math.min(xmin, vertices[i]);
						ymin = Math.min(ymin, vertices[i+1]);
						zmin = Math.min(zmin, vertices[i+2]);
						
						xmax = Math.max(xmax, vertices[i]);
						ymax = Math.max(ymax, vertices[i+1]);
						zmax = Math.max(zmax, vertices[i+2]);
					}
					boundingVolume.min = [xmin, ymin, zmin];
					boundingVolume.max = [xmax, ymax, zmax];
					boundingVolume.center = divideVec(addVec(boundingVolume.max, boundingVolume.min), 2);
					boundingVolume.diagonal = vecLength(subtractVec(boundingVolume.max, boundingVolume.min));
				}
				
				boundingVolume.xSize = boundingVolume.max[0]-boundingVolume.min[0];
				boundingVolume.ySize = boundingVolume.max[1]-boundingVolume.min[1];
				boundingVolume.zSize = boundingVolume.max[2]-boundingVolume.min[2];
			}
			
			function offset(x, y, z){
				return z + (y + x*boundingVolume.grid.yResolution)*boundingVolume.grid.zResolution;
			}
			
			function createGrid(){
				boundingVolume.grid = new Object();
				var maxResolution = 64;
				var a = 3 * Math.max(boundingVolume.xSize, boundingVolume.ySize, boundingVolume.zSize) / Math.pow(numShapes, 1.0/3.0);
				boundingVolume.grid.xResolution = Math.round(boundingVolume.xSize/a);
				boundingVolume.grid.xResolution = (boundingVolume.grid.xResolution < 1) ? 1 : 
													( (boundingVolume.grid.xResolution > maxResolution) ? 64 : boundingVolume.grid.xResolution);
				//boundingVolume.grid.xResolution = 2;
				boundingVolume.grid.yResolution = Math.round(boundingVolume.ySize/a);
				boundingVolume.grid.yResolution = (boundingVolume.grid.yResolution < 1) ? 1 : 
													( (boundingVolume.grid.yResolution > maxResolution) ? 64 : boundingVolume.grid.yResolution);
				//boundingVolume.grid.yResolution = 1;
				boundingVolume.grid.zResolution = Math.round(boundingVolume.zSize/a);
				boundingVolume.grid.zResolution = (boundingVolume.grid.zResolution < 1) ? 1 : 
													( (boundingVolume.grid.zResolution > maxResolution) ? 64 : boundingVolume.grid.zResolution);
				//boundingVolume.grid.zResolution = 1;
				//var minResolution = Math.min(boundingVolume.grid.xResolution, boundingVolume.grid.yResolution, boundingVolume.grid.zResolution);
				//boundingVolume.grid.xResolution = minResolution;
				//boundingVolume.grid.yResolution = minResolution;
				//boundingVolume.grid.zResolution = minResolution;
				//console.log("Resolutions: ",boundingVolume.grid.xResolution, boundingVolume.grid.yResolution, boundingVolume.grid.zResolution);
				boundingVolume.grid.metadata = new Array();
				boundingVolume.grid.voxels = new Array();
				boundingVolume.grid.numVoxels = boundingVolume.grid.xResolution * boundingVolume.grid.yResolution * boundingVolume.grid.zResolution;
				for (var i = 0; i < boundingVolume.grid.numVoxels; i++){
					boundingVolume.grid.metadata[i] = [0,0];
					boundingVolume.grid.voxels[i] = new Array();
				}
				
				if(shapeType == 1){
				
					var spheres = shapeData;
					for ( var i = 0; i < spheres.length; i+=16){
						var centers = [spheres[i], spheres[i+1], spheres[i+2]];
						var radius = spheres[i+3];
						var xmin = centers[0]-radius;
						var ymin = centers[1]-radius;
						var zmin = centers[2]-radius;
						
						var xmax = centers[0]+radius;
						var ymax = centers[1]+radius;
						var zmax = centers[2]+radius;
						
						var gridMin = gridIndex([xmin, ymin, zmin]);
						var gridMax = gridIndex([xmax, ymax, zmax]);
						for(var x = gridMin[0]; x <= gridMax[0]; x++)
							for(var y = gridMin[1]; y <= gridMax[1]; y++)
								for(var z = gridMin[2]; z <= gridMax[2]; z++)
									boundingVolume.grid.voxels[offset(x, y, z)].push(i/4);
						
					}
				}
				else if(shapeType == 2){					
					
					var vertices = shapeData;
					var indices = shapeIndices;
					for( var i = 0; i < indices.length; i+=4){
						var one = indices[i]*4;
						var two = indices[i+1]*4;
						var three = indices[i+2]*4;
						
						var xmin = Math.min(vertices[one], vertices[two], vertices[three]);
						var ymin = Math.min(vertices[one+1], vertices[two+1], vertices[three+1]);
						var zmin = Math.min(vertices[one+2], vertices[two+2], vertices[three+2]);
						
						var xmax = Math.max(vertices[one], vertices[two], vertices[three]);
						var ymax = Math.max(vertices[one+1], vertices[two+1], vertices[three+1]);
						var zmax = Math.max(vertices[one+2], vertices[two+2], vertices[three+2]);
						
						var gridMin = gridIndex([xmin, ymin, zmin]);
						var gridMax = gridIndex([xmax, ymax, zmax]);
						for(var x = gridMin[0]; x <= gridMax[0]; x++)
							for(var y = gridMin[1]; y <= gridMax[1]; y++)
								for(var z = gridMin[2]; z <= gridMax[2]; z++)
									boundingVolume.grid.voxels[offset(x, y, z)].push(i/4);
					}
				}
				
				boundingVolume.grid.metadataFlat = []
				boundingVolume.grid.voxelsFlat = [];
				var voxelOffset = 0;
				for (var i = 0; i < boundingVolume.grid.numVoxels; i++){
					var voxelLength = (boundingVolume.grid.voxels[i].length) ? boundingVolume.grid.voxels[i].length : 0;
					boundingVolume.grid.metadata[i] = [voxelLength, voxelOffset];
					voxelOffset += voxelLength;
					
					boundingVolume.grid.metadataFlat = boundingVolume.grid.metadataFlat.concat(boundingVolume.grid.metadata[i]);
					boundingVolume.grid.voxelsFlat = boundingVolume.grid.voxelsFlat.concat(boundingVolume.grid.voxels[i]);
				}
				//console.log(boundingVolume);
			}
			
			function gridIndex(point){
				var x = Math.round((point[0]-boundingVolume.min[0])/boundingVolume.xSize);
				x = (x < 0) ? 0 : ( (x > boundingVolume.grid.xResolution - 1) ? boundingVolume.grid.xResolution-1 : x);
				
				var y = Math.round((point[1]-boundingVolume.min[1])/boundingVolume.ySize);
				y = (y < 0) ? 0 : ( (y > boundingVolume.grid.yResolution - 1) ? boundingVolume.grid.yResolution-1 : y);
				
				var z = Math.round((point[2]-boundingVolume.min[2])/boundingVolume.zSize);
				z = (z < 0) ? 0 : ( (z > boundingVolume.grid.zResolution - 1) ? boundingVolume.grid.zResolution-1 : z);
				
				return [x, y, z];
			}
			
			function ApplyMatrix(matrix, data){
				var worldData = new Array();
				for(var i = 0; i < data.length; i+=3){
					var d0 = data[i];
					var d1 = data[i+1];
					var d2 = data[i+2];
					
					var n0 = matrix[0]*d0 + matrix[1]*d1 + matrix[2]*d2 + matrix[3];
					var n1 = matrix[4]*d0 + matrix[5]*d1 + matrix[6]*d2 + matrix[7];
					var n2 = matrix[8]*d0 + matrix[9]*d1 + matrix[10]*d2 + matrix[11];
					var n3 = matrix[12]*d0 + matrix[13]*d1 + matrix[14]*d2 + matrix[15];
					
					worldData.push(n0);
					worldData.push(n1);
					worldData.push(n2);
					worldData.push(n3);
				}
				return worldData;
			}
			
			function ApplyNormalMatrix(matrix, data){
				var normalMatrix = new Array();
				mat4.inverse(matrix, normalMatrix);
				mat4.transpose(normalMatrix);
				return ApplyMatrix(normalMatrix, data);
			}
			
			function ApplyOffset(offset, data){
				var newOffset = new Array();
				for(var i = 0; i < data.length; i++)
					newOffset[i] = data[i]+offset;
				return newOffset;
			}
			
			function loadScene(){	
				
				runCount = 0;
				console.log("Start Render");
				for ( x in clBuffers){
					clBuffers[x].releaseCLResources();
				}			
				shapeData = new Array();
				shapeNormals = new Array();
				shapeIndices = new Array();
				shapeMaterials = new Array();
				materialMetadata = new Array();
				materials = new Array();
				
				if(model.spheres){
					shapeType = 1;
					var numNodes = model.nodes.length;
					var centerData = [""];
					var radiiData = [""];
					for(var n = 0; n < numNodes; n++){
						var numSpheres = model.nodes[n].sphereIndices.length;
						for(var m = 0; m < numSpheres; m++){
							var sphereIndex = model.nodes[n].sphereIndices[m];
							var center;
							if(model.nodes[n].modelMatrix){
								center = ApplyMatrix(model.nodes[n].modelMatrix, model.spheres[sphereIndex].centers);
							}
							else{
								center = model.spheres[sphereIndex].centers;
							}
							
							shapeData.push(center[0]);
							shapeData.push(center[1]);
							shapeData.push(center[2]);
							shapeData.push(model.spheres[sphereIndex].radii[0]);
							
							var materialIndex = model.spheres[sphereIndex].materialIndex;
							
							if(model.materials[materialIndex].diffuseReflectance)
								shapeData.push(1);
							else
								shapeData.push(0);
								
							if(model.materials[materialIndex].emittance)
								shapeData.push(1);
							else
								shapeData.push(0);
								
							if(model.materials[materialIndex].specularReflectance)
								shapeData.push(1);
							else
								shapeData.push(0);
								
							if(model.materials[materialIndex].specularTransmittance)
								shapeData.push(model.materials[materialIndex].refractiveIndex);
							else
								shapeData.push(0);
								
							if(model.materials[materialIndex].diffuseReflectance){
								shapeData.push(model.materials[materialIndex].diffuseReflectance[0]);
								shapeData.push(model.materials[materialIndex].diffuseReflectance[1]);
								shapeData.push(model.materials[materialIndex].diffuseReflectance[2]);
								shapeData.push(1);
							}
							else if(model.materials[materialIndex].specularReflectance){
								shapeData.push(model.materials[materialIndex].specularReflectance[0]);
								shapeData.push(model.materials[materialIndex].specularReflectance[1]);
								shapeData.push(model.materials[materialIndex].specularReflectance[2]);
								shapeData.push(1);
							}
							else{
								shapeData.push(0);
								shapeData.push(0);
								shapeData.push(0);
								shapeData.push(0);
							}	
							
							if(model.materials[materialIndex].emittance){
								shapeData.push(model.materials[materialIndex].emittance[0]);
								shapeData.push(model.materials[materialIndex].emittance[1]);
								shapeData.push(model.materials[materialIndex].emittance[2]);
								shapeData.push(1);
							}
							else if(model.materials[materialIndex].specularTransmittance){
								shapeData.push(model.materials[materialIndex].specularTransmittance[0]);
								shapeData.push(model.materials[materialIndex].specularTransmittance[1]);
								shapeData.push(model.materials[materialIndex].specularTransmittance[2]);
								shapeData.push(1);
							}
							else{
								shapeData.push(0);
								shapeData.push(0);
								shapeData.push(0);
								shapeData.push(0);
							}							
							
								
						}
					}
					centerData.shift();
					radiiData.shift();
					//var j = 0;
					//for(var i = 3; i < centerData.length; i+=4){
					//	centerData[i] = radiiData[j++];
					//}
					//shapeData = centerData;
					
					//for(var i = 0; i < model.nodes[n].sphereIndices.length; i++){
						//shapeData.push(centerData[i*3]);
						//shapeData.push(centerData[i*3+1]);
						//shapeData.push(centerData[i*3+2]);
						//shapeData.push(radiiData[i]);
						//if(model.materials[model.nodes[
					//}
					
					shapeNormals[0] = 0;
					shapeIndices[0] = 0;
					numShapes = shapeData.length/16;
					//console.log(shapeData);
					
				}
				else if(model.meshes){
					shapeType = 2;
					var numNodes = model.nodes.length;
					var indexOffset = 0;
					for(var n = 0; n < numNodes; n++){
						var numMeshes = model.nodes[n].meshIndices.length;
						for(var m = 0; m < numMeshes; m++){
							var meshIndex = model.nodes[n].meshIndices[m];
							if(model.nodes[n].modelMatrix){
								if(shapeData){
									shapeData = shapeData.concat(ApplyMatrix(model.nodes[n].modelMatrix, model.meshes[meshIndex].vertexPositions));
									shapeNormals = shapeNormals.concat(ApplyNormalMatrix(model.nodes[n].modelMatrix, model.meshes[meshIndex].vertexNormals));
									shapeIndices = shapeIndices.concat(ApplyOffset(indexOffset, model.meshes[meshIndex].indices));
								}
								else{
									shapeData = ApplyMatrix(model.nodes[n].modelMatrix, model.meshes[meshIndex].vertexPositions);
									shapeNormals = ApplyNormalMatrix(model.nodes[n].modelMatrix, model.meshes[meshIndex].vertexNormals);
									shapeIndices = model.meshes[meshIndex].indices;
								}
							}
							else{
						
								if(shapeData){
									shapeData = shapeData.concat(padArray(model.meshes[meshIndex].vertexPositions, 3));
									shapeNormals = shapeNormals.concat(padArray(model.meshes[meshIndex].vertexNormals, 3));
									shapeIndices = shapeIndices.concat(ApplyOffset(indexOffset, model.meshes[meshIndex].indices));
								}
								else{
									shapeData = padArray(model.meshes[meshIndex].vertexPositions, 3);
									shapeNormals = padArray(model.meshes[meshIndex].vertexNormals, 3);
									shapeIndices = model.meshes[meshIndex].indices;
								}
							}
							indexOffset += model.meshes[meshIndex].indices.length;
						}
					}
					//console.log(shapeIndices);
					shapeIndices = padArray(shapeIndices, 3);
					numShapes = shapeIndices.length/4;
				}
				else{
					throw "Model error: No shape data";
				}
				//console.log(shapeIndices);
				//var sphereCenters = padArray(model.spheres[0].centers, 3);
				
				
				//console.log(shapeMaterials, materialMetadata, materials);
				
				clBuffers.shapeDataBuffer = clCtx.createBuffer(WebCL.CL_MEM_READ_ONLY, 4*shapeData.length);
				clBuffers.shapeNormalsBuffer = clCtx.createBuffer(WebCL.CL_MEM_READ_ONLY, 4*shapeNormals.length);
				clBuffers.shapeIndicesBuffer = clCtx.createBuffer(WebCL.CL_MEM_READ_ONLY, 4*shapeIndices.length);
				
				createBoundingVolume();
				createGrid();
				//console.log(boundingVolume);
				
				var eye = 0;
				var at = 0;
				var up = 0;
				var fov = 0;
				if( model.cameras ){
					camera.eye = model.cameras[0].eye;
					camera.at = model.cameras[0].at;
					camera.up = model.cameras[0].up;
					camera.fov = model.cameras[0].fov;
				}
				else{
					camera.eye = [boundingVolume.center[0], boundingVolume.center[1], boundingVolume.center[2]+boundingVolume.diagonal];
					camera.at = boundingVolume.center;
					camera.up = [0, 1, 0];
					camera.fov = 45;
				}
				
				camera.radius = vecLength(subtractVec(camera.eye, camera.at));
				camera.phi = 0;
				camera.theta = 90 * Math.PI / 180;
				
				var W = normalize( subtractVec(camera.eye, camera.at));
				var U = normalize( cross(camera.up, W));
				var V = cross( W, U);				
				var cameraData = padArray(camera.eye.concat(U, V, W), 3);
				var aspectRatio = canvas.width/canvas.height;
				var height = 2 * Math.tan(camera.fov*Math.PI/180/2);
				var width = aspectRatio * height;
				flags = [acceleration, 0, 0, 0];
				viewDimensions = [canvas.width, canvas.height, width, height].concat(
									boundingVolume.min, [0], 
									boundingVolume.max, [0], 
									[boundingVolume.grid.xResolution, boundingVolume.grid.yResolution, boundingVolume.grid.zResolution], [0]);
				var viewData = viewDimensions.concat(flags, cameraData);
				//console.log(viewData);
				clBuffers.viewDataBuffer = clCtx.createBuffer(WebCL.CL_MEM_READ_ONLY, 4*viewData.length);
				clBuffers.gridMetadataBuffer = clCtx.createBuffer(WebCL.CL_MEM_READ_ONLY, 4*boundingVolume.grid.metadataFlat.length);
				clBuffers.gridVoxelsBuffer = clCtx.createBuffer(WebCL.CL_MEM_READ_ONLY, 4*boundingVolume.grid.voxelsFlat.length);
				clBuffers.rasterBuffer = clCtx.createBuffer(WebCL.CL_MEM_READ_WRITE, 4*canvas.width*canvas.height);
				clBuffers.counterBuffer = clCtx.createBuffer(WebCL.CL_MEM_READ_WRITE, 4*canvas.width*canvas.height);
				
				var counters = new Uint32Array(canvas.width * canvas.height);
				for(var i = 0; i < canvas.width * canvas.height; i++)
					counters[i] = 0;
				
				seeds = new Uint32Array(canvas.width * canvas.height * 2);
				for(var i = 0; i < 2*canvas.width*canvas.height; i++){
					seeds[i] = Math.random() * 2147483647;
					if(seeds[i] < 2) {
						seeds[i] = 2;
					}
				}
				clBuffers.seedsBuffer = clCtx.createBuffer(WebCL.CL_MEM_READ_WRITE, 4*seeds.length);
				clBuffers.debugBuffer = clCtx.createBuffer(WebCL.CL_MEM_WRITE_ONLY, 4*shapeData.length);					

				clKernels.clearRasterKernel = clProgram.createKernel("clearRaster");
				clKernels.clearRasterKernel.setKernelArg(0, canvas.width, WebCL.types.INT);
				clKernels.clearRasterKernel.setKernelArg(1, clBuffers.rasterBuffer);
				
				
				clKernels.colorKernel = clProgram.createKernel("getPixelColor");
				clKernels.colorKernel.setKernelArg(0, shapeType, WebCL.types.INT);
				clKernels.colorKernel.setKernelArg(1, numShapes, WebCL.types.INT);
				clKernels.colorKernel.setKernelArg(2, clBuffers.viewDataBuffer);
				clKernels.colorKernel.setKernelArg(3, clBuffers.shapeDataBuffer);
				clKernels.colorKernel.setKernelArg(4, clBuffers.shapeNormalsBuffer);
				clKernels.colorKernel.setKernelArg(5, clBuffers.shapeIndicesBuffer);
				clKernels.colorKernel.setKernelArg(6, clBuffers.gridMetadataBuffer);
				clKernels.colorKernel.setKernelArg(7, clBuffers.gridVoxelsBuffer);
				clKernels.colorKernel.setKernelArg(8, clBuffers.rasterBuffer);
				clKernels.colorKernel.setKernelArg(9, clBuffers.seedsBuffer);
				clKernels.colorKernel.setKernelArg(10, clBuffers.counterBuffer);
				clKernels.colorKernel.setKernelArg(11, clBuffers.debugBuffer);
				//console.log(device);
				wsSize = clKernels.colorKernel.getKernelWorkGroupInfo(device, WebCL.CL_KERNEL_WORK_GROUP_SIZE);
				xSize = Math.floor(Math.sqrt(wsSize)); 
				ySize = Math.floor(wsSize/xSize);
				localWS = [xSize,ySize];
				globalWS = [
					Math.ceil (canvas.width / localWS[0]) * localWS[0], 
					Math.ceil (canvas.height / localWS[1]) * localWS[1]
				];
				
				clCQ.enqueueNDRangeKernel(clKernels.clearRasterKernel, globalWS.length, [], globalWS, localWS, []);
				clCQ.finish();
				var startTime = new Date().getTime();
				clCQ.enqueueWriteBuffer(clBuffers.viewDataBuffer, true, 0, 4*viewData.length, new Float32Array(viewData), []);
				clCQ.enqueueWriteBuffer(clBuffers.shapeDataBuffer, true, 0, 4*shapeData.length, new Float32Array(shapeData), []);
				clCQ.enqueueWriteBuffer(clBuffers.shapeNormalsBuffer, true, 0, 4*shapeNormals.length, new Float32Array(shapeNormals), []);
				clCQ.enqueueWriteBuffer(clBuffers.shapeIndicesBuffer, true, 0, 4*shapeIndices.length, new Uint32Array(shapeIndices), []);
				clCQ.enqueueWriteBuffer(clBuffers.gridMetadataBuffer, true, 0, 4*boundingVolume.grid.metadataFlat.length, new Uint32Array(boundingVolume.grid.metadataFlat), []);
				clCQ.enqueueWriteBuffer(clBuffers.gridVoxelsBuffer, true, 0, 4*boundingVolume.grid.voxelsFlat.length, new Uint32Array(boundingVolume.grid.voxelsFlat), []);
				clCQ.enqueueWriteBuffer(clBuffers.seedsBuffer, true, 0, 4*seeds.length, seeds, []);
				clCQ.enqueueWriteBuffer(clBuffers.counterBuffer, true, 0, 4*counters.length, counters, []);
				clCQ.enqueueNDRangeKernel(clKernels.colorKernel, globalWS.length, [], globalWS, localWS, []);
				clCQ.finish();
				//console.log("Compute time: "+(new Date().getTime()-startTime));	
				clCQ.enqueueReadBuffer(clBuffers.rasterBuffer, true, 0, canvas.width*canvas.height*4, raster.data, []);
				canvasCtx.putImageData(raster, 0, 0);
				sceneLoaded = true;
				
				//var debug = new Float32Array(shapeData.length);
				//clCQ.enqueueReadBuffer(clBuffers.debugBuffer, true, 0, 4*shapeData.length, debug, []);	
				//console.log(debug);
					
			}
			
			function updateRender(){
				render = !render;
			}
			
			function main(){
				document.getElementById("inputFile").value = "";
				//document.getElementById("acceleration").checked = false;
								
				try{
					canvas = document.getElementById("myCanvas");
					canvasCtx = canvas.getContext("2d");
					raster = canvasCtx.createImageData(canvas.width, canvas.height);
					
					platforms = WebCL.getPlatformIDs();
					for ( var i in platforms ){
						devices[i] = platforms[i].getDeviceIDs(WebCL.CL_DEVICE_TYPE_DEFAULT);
					}
					//console.log(platforms);
					//console.log(devices);
					device = devices[0][0];
					clCtx = WebCL.createContext([WebCL.CL_CONTEXT_PLATFORM, platforms[0]], devices[0]);
					clCQ = clCtx.createCommandQueue(devices[0][0], 0);
					clProgram = clCtx.createProgramWithSource(document.getElementById("openclProgram").text);
					clProgram.buildProgram(devices[0], "");
					
					var requestAnimationFrame = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;
					(function callback(){
						requestAnimationFrame(callback);
						if(sceneLoaded && render){
							if(rotate)
								updateCamera();
							updateScene();
						}
					})();
					//console.log(clBuffers);
				}catch(e){
					console.log(e);
					console.log(clProgram.getProgramBuildInfo(devices[0][0], WebCL.CL_PROGRAM_BUILD_LOG));
					return -1;
				}
			}
			
			function releaseResources(){
				for ( x in clBuffers){
					clBuffers[x].releaseCLResources();
				}
				for ( x in clKernels){
					clKernels[x].releaseCLResources();
				}
				clCQ.releaseCLResources();
				clProgram.releaseCLResources();
				clCtx.releaseCLResources();
			}
		</script>
	</head>
	<body onload="main();" onunload="releaseResources();">
		<p>Hello, please select a file. The file must be in the current directory.</p>
		<input type="file" id="inputFile" size="50" accept="application/json" onchange="loadFile();">
		<br>
		<div style="float:left">
			<canvas id="myCanvas" width="640" height="480"></canvas>
		</div>
		<div style="float:left">
			<!--p>Camera Controls</p>
			<input type="button" onclick="updateRotate();" value="Start/Stop Rotation">
			<input type="checkbox" id="acceleration" onchange="updateAcceleration();">Enable Acceleration
			<br-->
			<input type="button" onclick="updateRender();" value="Start/Stop Rendering">
			<input type="button" onclick="loadScene();" value="Reset">
		</div>
	</body>
</html>

