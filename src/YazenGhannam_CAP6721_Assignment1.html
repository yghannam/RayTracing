<!--
Author: Yazen Ghannam
Spring 2013
CAP 6721
Assignment 1
-->
<!DOCTYPE html>
<html>
	<head>
		<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
		<meta content="utf-8" http-equiv="encoding">
		<script id="openclProgram" type="text/x-opencl">
			float raySphere(float3 rayOrigin, float3 rayDirection, float3 sphereCenter, float sphereRadius){
				float a = dot(rayDirection, rayDirection);
				float b = 2.0*(dot(rayOrigin,rayDirection)-dot(sphereCenter,rayDirection));
				float c = dot(rayOrigin, rayOrigin) - 2.0*dot(sphereCenter, rayOrigin) +dot(sphereCenter, sphereCenter) - sphereRadius*sphereRadius;
				float radicand = b*b - 4*a*c;
				if (radicand < 0){
					return 0;
				}
				else if (radicand == 0){
					return -b/(2*a);
				}
				else{
					float root = sqrt(radicand);
					float x1 = (-b+root)/(2*a);
					float x2 = (-b-root)/(2*a);
					if(x1 > 0 && x2 > 0){
						return (x1 < x2) ? x1:x2;
					}
					else if (x1 > 0 && x2 <= 0){
						return x1;
					}
					else if (x1 <= 0 && x2 > 0){
						return x2;
					}
					else{
						return 0;
					}
				}
			}
			__kernel void getPixelColor(
				const int columns,
				const int rows,
				const float width,
				const float height,
				const int numSpheres,
				__global float3 *camera,
				__global float3 *sphereCenters,
				__global float *sphereRadii,
				__global uchar4 *raster){
					const int col = get_global_id(0);
					const int row = get_global_id(1);
					float3 eye = camera[0];
					float3 at = camera[1];
					float3 up = camera[2];
					
					float3 temp = eye-at;
					float3 W = temp/normalize(temp);
					temp = cross(up, W);
					float3 U = temp/normalize(temp);
					float3 V = cross(W, U);
					
					float3 ray;
					ray.x = width * ( (col+0.5)/columns - 0.5);
					ray.y = height * (0.5 - (row+0.5)/rows);
					ray.z = -1;
					
					
					// Object index, t
					float minT = INFINITY;
					int objectIndex = -1;
					for( int i = 0; i < numSpheres; i++){
						float t = raySphere(eye, ray, sphereCenters[i], sphereRadii[i]);
						if (t > 0){
							minT = min(minT, t);
						}
						if (minT == t){
							objectIndex = i;
						}
					}
					uchar4 color = (uchar4)(0, 0, 0, 255);
					if ( objectIndex >= 0 ){
						color = (uchar4)(255, 255, 255, 255);
					}
					
					raster[row * columns + col] = color;
				}
		</script>
		<script type="text/javascript">
			var model = null;
			var platforms = null;
			var devices = [];
			var canvas = null;
			var canvasCtx = null;
			var raster = null;
			var rv = null;
			var device = null;
			var clCtx = null;
			var clCQ = null;
			var clProgram = null;
			var clKernels = new Object();
			var clBuffers = new Object();
			
			function parseJSON(jsonFile){
				var xhttp = new XMLHttpRequest();
				xhttp.open("GET", jsonFile, false);				
				xhttp.overrideMimeType("application/json");
				xhttp.send(null);
				//console.log(jsonFile);
				//console.log(xhttp);
				return JSON.parse(xhttp.responseText);
			}
			
			function loadFile(){
				model = parseJSON(document.getElementById("inputFile").value);
				//console.log(model);
				run();
			}
			
			function run(){
				
				var camera = model.cameras[0].eye.concat(model.cameras[0].at, model.cameras[0].up);
				//console.log(camera);
				clBuffers.cameraBuffer = clCtx.createBuffer(WebCL.CL_MEM_READ_ONLY, 4*camera.length);
				var fov = model.cameras[0].fov;
				//console.log(fov);
				clBuffers.sphereCentersBuffer = clCtx.createBuffer(WebCL.CL_MEM_READ_ONLY, 4*model.spheres[0].centers.length);
				clBuffers.sphereRadiiBuffer = clCtx.createBuffer(WebCL.CL_MEM_READ_ONLY, 4*model.spheres[0].radii.length);
				var aspectRatio = canvas.width/canvas.height;
				var height = 2 * Math.tan(fov*Math.PI/180/2);
				var width = aspectRatio * height;
				
				clKernels.colorKernel = clProgram.createKernel("getPixelColor");
				clBuffers.rasterBuffer = clCtx.createBuffer(WebCL.CL_MEM_WRITE_ONLY, canvas.width*canvas.height*4);					
				clKernels.colorKernel.setKernelArg(0, canvas.width, WebCL.types.UINT);
				clKernels.colorKernel.setKernelArg(1, canvas.height, WebCL.types.UINT);
				clKernels.colorKernel.setKernelArg(2, width, WebCL.types.FLOAT);
				clKernels.colorKernel.setKernelArg(3, height, WebCL.types.FLOAT);
				clKernels.colorKernel.setKernelArg(4, model.spheres[0].radii.length, WebCL.types.INT);
				clKernels.colorKernel.setKernelArg(5, clBuffers.cameraBuffer);
				clKernels.colorKernel.setKernelArg(6, clBuffers.sphereCentersBuffer);
				clKernels.colorKernel.setKernelArg(7, clBuffers.sphereRadiiBuffer);
				clKernels.colorKernel.setKernelArg(8, clBuffers.rasterBuffer);
					
				clCQ.enqueueWriteBuffer(clBuffers.cameraBuffer, true, 0, 4*camera.length, new Float32Array(camera), []);
				clCQ.enqueueWriteBuffer(clBuffers.sphereCentersBuffer, true, 0, 4*model.spheres[0].centers.length, new Float32Array(model.spheres[0].centers), []);
				clCQ.enqueueWriteBuffer(clBuffers.sphereRadiiBuffer, true, 0, 4*model.spheres[0].radii.length, new Float32Array(model.spheres[0].radii), []);
				clCQ.enqueueNDRangeKernel(clKernels.colorKernel, 2, [], [canvas.width, canvas.height], [], []);
				clCQ.finish();
					
				clCQ.enqueueReadBuffer(clBuffers.rasterBuffer, true, 0, canvas.width*canvas.height*4, raster.data, []);
				canvasCtx.putImageData(raster, 0, 0);
					
					
					
			}
			
			function printClError(err){
				var errString="";
				switch (err) {
					case CL_SUCCESS:                            errString = "Success!"; break;
					case CL_DEVICE_NOT_FOUND:                   errString = "Device not found."; break;
					case CL_DEVICE_NOT_AVAILABLE:               errString = "Device not available"; break;
					case CL_COMPILER_NOT_AVAILABLE:             errString = "Compiler not available"; break;
					case CL_MEM_OBJECT_ALLOCATION_FAILURE:      errString = "Memory object allocation failure"; break;
					case CL_OUT_OF_RESOURCES:                   errString = "Out of resources"; break;
					case CL_OUT_OF_HOST_MEMORY:                 errString = "Out of host memory"; break;
					case CL_PROFILING_INFO_NOT_AVAILABLE:       errString = "Profiling information not available"; break;
					case CL_MEM_COPY_OVERLAP:                   errString = "Memory copy overlap"; break;
					case CL_IMAGE_FORMAT_MISMATCH:              errString = "Image format mismatch"; break;
					case CL_IMAGE_FORMAT_NOT_SUPPORTED:         errString = "Image format not supported"; break;
					case CL_BUILD_PROGRAM_FAILURE:              errString = "Program build failure"; break;
					case CL_MAP_FAILURE:                        errString = "Map failure"; break;
					case CL_MISALIGNED_SUB_BUFFER_OFFSET:       errString = "Map failure"; break;
					case CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST: errString = "Execution Status Error for Events in Wait List"; break;
					case CL_COMPILE_PROGRAM_FAILURE:            errString = "Compile Program failure"; break;
					case CL_LINKER_NOT_AVAILABLE:               errString = "Linker Not Available"; break;
					case CL_LINK_PROGRAM_FAILURE:               errString = "Link Program failure"; break;
					case CL_DEVICE_PARTITION_FAILED:            errString = "Device Partition Failed"; break;
					case CL_KERNEL_ARG_INFO_NOT_AVAILABLE:      errString = "Kernel Argument Information Not Available"; break;
					case CL_INVALID_VALUE:                      errString = "Invalid value"; break;
					case CL_INVALID_DEVICE_TYPE:                errString = "Invalid device type"; break;
					case CL_INVALID_PLATFORM:                   errString = "Invalid platform"; break;
					case CL_INVALID_DEVICE:                     errString = "Invalid device"; break;
					case CL_INVALID_CONTEXT:                    errString = "Invalid context"; break;
					case CL_INVALID_QUEUE_PROPERTIES:           errString = "Invalid queue properties"; break;
					case CL_INVALID_COMMAND_QUEUE:              errString = "Invalid command queue"; break;
					case CL_INVALID_HOST_PTR:                   errString = "Invalid host pointer"; break;
					case CL_INVALID_MEM_OBJECT:                 errString = "Invalid memory object"; break;
					case CL_INVALID_IMAGE_FORMAT_DESCRIPTOR:    errString = "Invalid image format descriptor"; break;
					case CL_INVALID_IMAGE_SIZE:                 errString = "Invalid image size"; break;
					case CL_INVALID_SAMPLER:                    errString = "Invalid sampler"; break;
					case CL_INVALID_BINARY:                     errString = "Invalid binary"; break;
					case CL_INVALID_BUILD_OPTIONS:              errString = "Invalid build options"; break;
					case CL_INVALID_PROGRAM:                    errString = "Invalid program"; break;
					case CL_INVALID_PROGRAM_EXECUTABLE:         errString = "Invalid program executable"; break;
					case CL_INVALID_KERNEL_NAME:                errString = "Invalid kernel name"; break;
					case CL_INVALID_KERNEL_DEFINITION:          errString = "Invalid kernel definition"; break;
					case CL_INVALID_KERNEL:                     errString = "Invalid kernel"; break;
					case CL_INVALID_ARG_INDEX:                  errString = "Invalid argument index"; break;
					case CL_INVALID_ARG_VALUE:                  errString = "Invalid argument value"; break;
					case CL_INVALID_ARG_SIZE:                   errString = "Invalid argument size"; break;
					case CL_INVALID_KERNEL_ARGS:                errString = "Invalid kernel arguments"; break;
					case CL_INVALID_WORK_DIMENSION:             errString = "Invalid work dimension"; break;
					case CL_INVALID_WORK_GROUP_SIZE:            errString = "Invalid work group size"; break;
					case CL_INVALID_WORK_ITEM_SIZE:             errString = "Invalid work item size"; break;
					case CL_INVALID_GLOBAL_OFFSET:              errString = "Invalid global offset"; break;
					case CL_INVALID_EVENT_WAIT_LIST:            errString = "Invalid event wait list"; break;
					case CL_INVALID_EVENT:                      errString = "Invalid event"; break;
					case CL_INVALID_OPERATION:                  errString = "Invalid operation"; break;
					case CL_INVALID_GL_OBJECT:                  errString = "Invalid OpenGL object"; break;
					case CL_INVALID_BUFFER_SIZE:                errString = "Invalid buffer size"; break;
					case CL_INVALID_MIP_LEVEL:                  errString = "Invalid mip-map level"; break;
					case CL_INVALID_GLOBAL_WORK_SIZE:           errString = "Invalid Global Work Size"; break;
					case CL_INVALID_IMAGE_DESCRIPTOR:           errString = "Invalid Image Descriptor";break;
					case CL_INVALID_COMPILER_OPTIONS:           errString = "Invalid Compiler Options";break;
					case CL_INVALID_LINKER_OPTIONS:             errString = "Invalid Linker Options";break;
					case CL_INVALID_DEVICE_PARTITION_COUNT:     errString = "Invalid Device Partition Count";break;
					default: errString = "Unknown error"; break;
				}
				return errString;
			}
			function main(){
				document.getElementById("inputFile").value = "";
				
				try{
					canvas = document.getElementById("myCanvas");
					canvasCtx = canvas.getContext("2d");
					raster = canvasCtx.createImageData(canvas.width, canvas.height);
					
					platforms = WebCL.getPlatformIDs();
					for ( var i in platforms ){
						devices[i] = platforms[i].getDeviceIDs(WebCL.CL_DEVICE_TYPE_DEFAULT);
					}
					//console.log(platforms);
					//console.log(devices);
					clCtx = WebCL.createContext([WebCL.CL_CONTEXT_PLATFORM, platforms[0]], devices[0]);
					clCQ = clCtx.createCommandQueue(devices[0][0], 0);
					clProgram = clCtx.createProgramWithSource(document.getElementById("openclProgram").text);
					clProgram.buildProgram(devices[0], "");
					
					
					//console.log(clBuffers);
				}catch(e){
					console.log(e);
					console.log(device);
					console.log(clProgram.getProgramBuildInfo(device, WebCL.CL_PROGRAM_BUILD_LOG));
					//alert(e);
					return -1;
				}
			}
			
			function releaseResources(){
				for ( x in clBuffers){
					clBuffers[x].releaseCLResources();
				}
				for ( x in clKernels){
					clKernels[x].releaseCLResources();
				}
				clCQ.releaseCLResources();
				clProgram.releaseCLResources();
				clCtx.releaseCLResources();
			}
		</script>
	</head>
	<body onload="main();" onunload="releaseResources();">
		<p>Hello, I'm using WebCL to render a black to white gradient on the canvas.</p>
		<input type="file" id="inputFile" size="50" accept="application/json" onchange="loadFile();">
		<br>
		<canvas id="myCanvas" width=320 height=240></canvas>
	</body>
</html>

